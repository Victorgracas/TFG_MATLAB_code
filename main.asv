function main()
    % Parámetros de la caja (en metros)
    length_caja = 110 * 0.0254; % 110 pulgadas a metros
    width_caja = 50 * 0.0254;   % 50 pulgadas a metros
    height_caja = 54 * 0.0254;  % 54 pulgadas a metros

    % Parámetros de simulación
    Atenuacio_maleta = 3; % Atenuación por maleta en dB
    Perdues_k = 2; % Pérdidas inespecíficas en dB
    Posicio_TAG = 'random'; % Posición del TAG: 'inside', 'outside' o 'random'
    Dimensions_maletes = 'random'; % Dimensiones de las maletas: 'random' o 'std'
    k_perdidas = 2; % Pérdidas inespecíficas

    % Parámetros del lector (América)
    Pt = 33; % Potencia de transmisión del lector en dBm
    S_lectora = -92; % Sensibilidad del receptor del lector en dBm

    % Parámetros del tag
    Ganancia_TAG = 2.15;
    Coef_reflexion = 0.8;
    Sensibilidad_lectura_tag = -24; % Sensibilidad de lectura del tag en dBm
    Sensibilidad_escritura_tag = -21; % Sensibilidad de escritura del tag en dBm
    Max_potencia_rx = 20;
    Rango_Angulos_TAG = [0, 0]; % Rango de ángulos para el TAG en grados

    % Posiciones de las antenas en el lector (agregamos una antena)
    num_antenna = 1;
    reader_pos = [
        0, length_caja/2, height_caja; % Primera antena
        % width_caja, length_caja/2, height_caja;
    ];

    tipoAntenaLector = 'Compare Mode'; % 'FXR90', 'AN520' o 'Compare Mode'

    % Generar posiciones de lectores y su dirección
    [antennas_pos, vectors_dir] = calculate_antenna_vectors(num_antenna, reader_pos);
    % Generar posiciones de maletas y tags
    [maletas_pos, maletas_dim, tags_pos] = TAG_matrix(Posicio_TAG, Dimensions_maletes, antennas_pos, vectors_dir);

    % Selección de antenas según el modo
    if strcmp(tipoAntenaLector, 'Compare Mode')
        antenasAUsar = {'FXR90', 'AN520'};
    else
        antenasAUsar = {tipoAntenaLector}; % Sólo una antena
    end

    % Inicializar matriz para almacenar resultados de link budget para cada antena
    num_tags = size(tags_pos, 1);
    link_budget_results = zeros(num_tags, length(antenasAUsar), 2); % [n_tags, n_antenas, 2 (Potencia y Suficiencia)]

    % Cálculo del link budget para cada antena del lector y cada etiqueta
    for antenaIdx = 1:length(antenasAUsar)
        tipoAntena = antenasAUsar{antenaIdx};

        for i = 1:num_tags
            % Inicializar flag que indica si el tag ha sido leído por alguna antena
            tag_leido = false;

            % Para cada antena, evaluar si tiene suficiente potencia para leer el tag
            for antennaPosIdx = 1:size(reader_pos, 1)
                % Obtener la posición de la antena y su vector de dirección
                current_antenna_pos = reader_pos(antennaPosIdx, :);
                current_vector_dir = vectors_dir(antennaPosIdx, :);

                % Distancia entre la antena y el tag
                distancia = norm(tags_pos(i, :) - current_antenna_pos);

                % Vector que une la antena con el tag
                vector_lector_tag = tags_pos(i, :) - current_antenna_pos;

                % Calcular el ángulo con respecto al eje Z (ángulo de elevación)
                theta = acosd(-vector_lector_tag(3) / distancia); % Ángulo en grados respecto al eje Z

                % Calcular el ángulo azimutal (phi) respecto al vector de dirección
                cos_phi = dot(vector_lector_tag(1:2), current_vector_dir(1:2)) / (norm(vector_lector_tag(1:2)) * norm(current_vector_dir(1:2)));
                phi = acosd(cos_phi); % Ángulo en grados

                % Calcular ganancia efectiva del lector en función de los ángulos
                G_eff_lector = Antenna_Gain(tipoAntena, phi, theta); % Considerar ambos planos

                % Calcular ángulo random entre el rango dado en los parámetros para el TAG
                angulo_TAG = 360 * rand();

                % Calcular ganancia efectiva del tag en función del ángulo combinado
                G_eff_tag = Antenna_Gain('TAG', angulo_TAG, 0); % Solo se usa el ángulo vertical para el TAG

                % Cálculo de la pérdida de propagación en espacio libre (Friis)
                lambda = 3e8 / (868e6); % Longitud de onda en metros para 868 MHz
                FSL = 20 * log10(4 * pi * distancia / lambda); % Pérdida de espacio libre en dB

                % Calcular la atenuación por maletas
                [num_maletas, atenuacion_maletas_db] = atenuacion_maletas(maletas_pos, maletas_dim, current_antenna_pos, tags_pos(i, :), Atenuacio_maleta);

                % Cálculo de la potencia recibida en el tag (Ida)
                Pr_tag = Pt + G_eff_lector - (k_perdidas + FSL + atenuacion_maletas_db) + G_eff_tag; % Potencia recibida en el tag en dBm

                % Verificar si es suficiente para leer el tag
                if Pr_tag >= Sensibilidad_lectura_tag
                    % **Cálculo del link budget de vuelta** (desde el tag hacia el lector)
                    % Potencia reflejada por el tag (coeficiente de reflexión aplicado)
                    Pr_vuelta_tag = Pr_tag + 10 * log10(Coef_reflexion^2); % Potencia reflejada

                    % Pérdidas de espacio libre para la señal de vuelta
                    FSL_vuelta = FSL; % Igual que el FSL de ida

                    % Potencia recibida por el lector (de vuelta)
                    Pr_lector = Pr_vuelta_tag + G_eff_tag + G_eff_lector - FSL_vuelta - atenuacion_maletas_db;

                    % Verificar si la potencia de vuelta es suficiente para que el lector lea el tag
                    if Pr_lector >= S_lectora
                        link_budget_results(i, antenaIdx, 1) = Pr_tag; % Guardar la potencia de vuelta
                        link_budget_results(i, antenaIdx, 2) = Pr_lector; % Guardar la potencia de vuelta
                        link_budget_results(i, antenaIdx, 3) = 1; % Es suficiente para leer de vuelta
                        tag_leido = true; % El tag ha sido leído por esta antena
                    else
                        link_budget_results(i, antenaIdx, 1) = Pr_lector; % Guardar la potencia de vuelta
                        link_budget_results(i, antenaIdx, 2) = 0; % No es suficiente para leer de vuelta
                    end

                    break; % Salimos del bucle si el tag es leído por esta posición de antena
                else
                    link_budget_results(i, antenaIdx, 1) = Pr_tag; % Guardar la potencia de ida
                    link_budget_results(i, antenaIdx, 2) = 0; % No es suficiente para leer en ida
                end
            end

            % Si el tag ha sido leído, no se necesita evaluar más antenas en esta iteración
            if tag_leido
                fprintf('Tag %d ha sido leído por la antena %s\n', i, tipoAntena);
            else
                fprintf('Tag %d no ha sido leído por la antena %s\n', i, tipoAntena);
            end
        end

        % Llamar al plot para cada antena simulada
        plot_tags_with_read_status(link_budget_results, maletas_pos, maletas_dim, tags_pos, antennas_pos, tipoAntena);
    end
end
